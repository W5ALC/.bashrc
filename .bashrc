# .bashrc

# Source global bash config
if [ -f /etc/bashrc ]; then
source /etc/bashrc
fi

# Create an array of potential dotfiles
dotfiles=(
  "${HOME}/.bash_aliases"
  "${HOME}/.bash_functions"
  "${HOME}/.bashrc_colors"
  "${HOME}/.text_functions"
)

# Work through our list of dotfiles, if a match is found, load it
# shellcheck source=/dev/null
for dotfile in "${dotfiles[@]}"; do
  [[ -r "${dotfile}" ]] && source "${dotfile}"
done

unset dotfiles; unset -v dotfile

# This will show if there is an active SSH connection after each command is executed.
ssh_psONE() # Shows login before last of current user; best used with AllowUsers in sshd_config
{
if [[ "$(last | sed -n '2p' | awk '{ print $3 }')" =~ ("172.58."*|"67.190.156.142"|"10.0.0.83"|"10.0.2.2") ]]; then
printf %b "\\[\\e[1;32m\\]My Phone\n"
else
last | sed -n '2p' | awk '{ print $3 }'
fi
}

localpsONE() # Shows the last login from the current user; best used with AllowUsers in sshd_config
{
if [[ "$(lastlog | grep $(whoami) | awk '{ print $3 }')" =~ ("172.58."*|"67.190.156.142"|"10.0.0.83"|"10.0.2.2") ]]; then
printf %b "\\[\\e[1;32m\\]My Phone\n"
else
lastlog | grep $(whoami) | awk '{ print $3 }'
fi
}
if [[ -n $SSH_CLIENT ]]; then
	PS1="\\[\\e[1;31m\\]üü¢ $(ssh_psONE)\\[\\e[0m\\]\\[\\e[1;33m\\]\n\w/\n\\[\\e[0m\\]\\[\\e[1;31m\\]ùùÖ \\[\\e[0m\\]\\[\\e[1;32m\\] "
else
	ss -tn src :8222 | grep ESTAB &> /dev/null
    if [ $? -ne "1" ]; then
	PS1="\\[\\e[1;31m\\]üü¢ $(localpsONE)\\[\\e[1;33m\\]\n\w/\n\\[\\e[0m\\]\\[\\e[1;31m\\]ùùÖ\\[\\e[0m\\]\\[\\e[1;32m\\] "
    else
	PS1="\\[\\e[1;31m\\]üî¥ $(localpsONE)\\[\\e[1;33m\\]\n\w/\n\\[\\e[0m\\]\\[\\e[1;31m\\]ùùÖ\\[\\e[0m\\]\\[\\e[1;32m\\] "
    fi
fi}

alias bashr="nano ~/.bashrc && source ~/.bashrc" # edit .bashrc and source it.
alias bashf="nano ~/.bash_functions && source ~/.bash_functions" # edit .bash_functions and source it.
alias basha="nano ~/.bash_aliases && source ~/.bash_aliases" # edit .bash_aliases and source it.

alias scmd='fc -ln -1 | sed "s/^\s*//" >> ~/.saved_cmds.txt' # save last command to ~/saved_cmds.txt
alias rcmd='eval $(fzf < ~/.saved_cmds.txt)' # search through ~/saved_cmds.txt and run selected

# User specific $PATH
if ! [[ "$PATH" =~ "$HOME/.local/bin:$HOME/bin:" ]]
then
    PATH="$HOME/.local/bin:$HOME/bin:$PATH"
fi

#if [[ -n $SSH_CLIENT ]]; then
#	PS1="\\[\\e[1;32m\\]üü¢ $(last | sed -n '2p' | awk '{ print $3 }')\\[\\e[0m\\]\\[\\e[1;33m\\]\n\w/\n\\[\\e[0m\\]\\[\\e[1;31m\\]ùùÖ \\[\\e[0m\\]\\[\\e[1;32m\\] "
#else
#	ss -tn src :8222 | grep ESTAB &> /dev/null
#    if [ $? -ne "1" ]; then
#	PS1="\\[\\e[1;31m\\]üü° $(lastlog | grep $(whoami) | awk '{ print $3 }')\\[\\e[1;33m\\]\n\w/\n\\[\\e[0m\\]\\[\\e[1;31m\\]ùùÖ\\[\\e[0m\\]\\[\\e[1;32m\\] "
#    else
#	PS1="\\[\\e[1;31m\\]üü¢ $(lastlog | grep $(whoami) | awk '{ print $3 }')\\[\\e[1;33m\\]\n\w/\n\\[\\e[0m\\]\\[\\e[1;31m\\]ùùÖ\\[\\e[0m\\]\\[\\e[1;32m\\] "
#    fi
#fi
PS2=""
PS4='-[\e[33m${BASH_SOURCE/.sh}\e[0m: \e[32m${LINENO}\e[0m] '
PS4+='${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
# Export variables
export PATH
HISTSIZE=-1 # unlimited history file
HISTFILESIZE=-1 # unlimited history file
HISTCONTROL=ignorespace:ignoredups:erasedups
shopt -s histappend
PROMPT_COMMAND="_prompt_command; history -n; history -w; history -c; history -r; $PROMPT_COMMAND"
export HISTIGNORE=$'[ \t]*:&:[fb]g:[ewr][xcz][iou][try]:ls'
export DBUS_SESSION_BUS_ADDRESS="unix:path=/run/user/$(id -u)/bus"
export LESS='-i -N -w  -z-4 -g -e -M -X -F -R -P%t?f%f \
:stdin .?pb%pb\%:?lbLine %lb:?bbByte %bb:-...'
GREP_COLORS='sl=48;5;234;39;1:cx=48;5;235;91;1:mt=49;91;1:fn=49;91;1:ln=49;38;5;154;1:bn=49;38;5;97;1:se=49;38;5;81;1';
# Generated by hand, referencing http://linux-sxs.org/housekeeping/lscolors.html
# and https://geoff.greer.fm/lscolors/
LS_COLORS='di=1;32:ln=1;30;47:so=30;45:pi=30;45:ex=1;31:bd=30;46:cd=30;46:su=30'
LS_COLORS="${LS_COLORS};41:sg=30;41:tw=30;41:ow=30;41:*.rpm=1;31:*.deb=1;31"
LSCOLORS=CxahafafBxagagabababab

export GREP_COLORS LS_COLORS LSCOLORS

# Check for dircolors and if found, process .dircolors
# This sets up colours for 'ls' via LS_COLORS
if [[ -z "${LS_COLORS}" ]] && get_command dircolors; then
  if [[ -r ~/.dircolors ]]; then
    eval "$(dircolors -b ~/.dircolors)"
  elif [[ -r /etc/DIR_COLORS ]] ; then
    eval "$(dircolors -b /etc/DIR_COLORS)"
  else
    eval "$(dircolors -b)"
  fi
fi

# LESS man page colors (makes Man pages more readable).
export LESS_TERMCAP_mb=$'\E[01;31m'
export LESS_TERMCAP_md=$'\E[01;31m'
export LESS_TERMCAP_me=$'\E[0m'
export LESS_TERMCAP_se=$'\E[0m'
export LESS_TERMCAP_so=$'\E[01;44;33m'
export LESS_TERMCAP_ue=$'\E[0m'
export LESS_TERMCAP_us=$'\E[01;32m'
shopt -s lithist
shopt -s checkwinsize
shopt -s globstar
shopt -s dotglob
shopt -s cmdhist
shopt -s autocd
shopt -s cdspell

# shopt -s dirspell
# shopt -s complete_fullquote
# shopt -s execfail
# shopt -s extquote
shopt -s force_fignore
# shopt -s huponexit
shopt -s nocaseglob
shopt -s nocasematch
# shopt -s progcomp
# shopt -s promptvars
# shopt -s shift_verbose
# shopt -s xpg_echo
alias nano='nano -m'

# set +xeuo pipefail
set -o notify
set -o ignoreeof
clear
# Uncomment the following line if you don't like systemctl's auto-paging feature:
# export SYSTEMD_PAGER=

export LESS='FiX'
#shopt -q login_shell && echo 'Login shell' || echo 'Not login shell'
